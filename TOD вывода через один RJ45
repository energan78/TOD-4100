#include <WiFi.h>
#include <time.h>

const char* ssid = "izm-22";
const char* password = "80577561578";

const char* ntpServer = "31.202.14.125";
const long gmtOffset_sec = 0;
const int daylightOffset_sec = 0;

// –ü–∏–Ω—ã –¥–ª—è PPS –∏ TOD –≤—ã–≤–æ–¥–∞ —á–µ—Ä–µ–∑ –æ–¥–∏–Ω RJ45
const int ppsPin = 4;

// –ü–∏–Ω—ã –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ TOD –≤—ã–≤–æ–¥–∞
const int todData0 = 12;  // DATA BIT 0
const int todData1 = 13;  // DATA BIT 1  
const int todData2 = 14;  // DATA BIT 2
const int todData3 = 15;  // DATA BIT 3
const int todData4 = 16;  // DATA BIT 4
const int todData5 = 17;  // DATA BIT 5
const int todData6 = 18;  // DATA BIT 6
const int todData7 = 19;  // DATA BIT 7
const int todStrobe = 21; // –°—Ç—Ä–æ–±-—Å–∏–≥–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö
const int todSelect = 22; // –í—ã–±–æ—Ä –≤—Ä–µ–º–µ–Ω–∏/–¥–∞—Ç—ã (0=–≤—Ä–µ–º—è, 1=–¥–∞—Ç–∞)

// –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç—ã
volatile unsigned long lastPpsMicros = 0;
volatile unsigned long ppsCounter = 0;
volatile bool ppsReceived = false;
volatile unsigned long lastStablePps = 0;

bool externalClockActive = false;
unsigned long lastNtpSync = 0;
unsigned long stablePpsCount = 0;
float averageInterval = 1000000.0;

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø–æ–ª–Ω—ã—Ö TOD –¥–∞–Ω–Ω—ã—Ö
struct TodData {
  // –í—Ä–µ–º—è
  uint8_t hours;
  uint8_t minutes; 
  uint8_t seconds;
  uint16_t milliseconds;
  
  // –î–∞—Ç–∞
  uint8_t day;
  uint8_t month;
  uint16_t year;
  uint8_t dayOfWeek;
  
  // –°—Ç–∞—Ç—É—Å
  uint32_t ppsCounter;
  bool ppsLocked;
};

void IRAM_ATTR ppsInterrupt() {
  unsigned long currentMicros = micros();
  unsigned long interval = currentMicros - lastPpsMicros;
  
  if (lastPpsMicros > 0) {
    if (interval > 800000 && interval < 1200000) {
      averageInterval = (averageInterval * 0.9) + (interval * 0.1);
      lastStablePps = currentMicros;
      stablePpsCount++;
    }
  }
  
  lastPpsMicros = currentMicros;
  ppsCounter++;
  ppsReceived = true;
}

void updateTimeFromPps() {
  struct timeval tv;
  if (gettimeofday(&tv, NULL) == 0) {
    tv.tv_sec += 1;
    tv.tv_usec = 0;
    settimeofday(&tv, NULL);
  }
}

void outputTodSerial(const TodData& tod) {
  // –ü–æ–ª–Ω—ã–π –≤—ã–≤–æ–¥ —Å –¥–∞—Ç–æ–π –∏ –≤—Ä–µ–º–µ–Ω–µ–º
  Serial.printf("üìÖ TOD: %04d-%02d-%02d %02d:%02d:%02d.%03d", 
               tod.year, tod.month, tod.day,
               tod.hours, tod.minutes, tod.seconds, tod.milliseconds);
  
  Serial.printf(" [DoW: %d]", tod.dayOfWeek);
  
  if (tod.ppsLocked) {
    Serial.printf(" [PPS #%lu] ‚úÖ", tod.ppsCounter);
    
    float drift = (averageInterval - 1000000.0) / 1000.0;
    if (fabs(drift) > 0.5) {
      Serial.printf(" Drift: %.1fms", drift);
    }
  } else {
    Serial.printf(" [FREE #%lu] ‚ö†Ô∏è", tod.ppsCounter);
  }
  
  if (stablePpsCount > 0) {
    Serial.printf(" Stable: %lu", stablePpsCount);
  }
  
  Serial.println();
}

void outputDataToBus(uint16_t data) {
  // –í—ã–≤–æ–¥ 8-–±–∏—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —à–∏–Ω—É
  digitalWrite(todData0, (data & 0x01) ? HIGH : LOW);
  digitalWrite(todData1, (data & 0x02) ? HIGH : LOW);
  digitalWrite(todData2, (data & 0x04) ? HIGH : LOW);
  digitalWrite(todData3, (data & 0x08) ? HIGH : LOW);
  digitalWrite(todData4, (data & 0x10) ? HIGH : LOW);
  digitalWrite(todData5, (data & 0x20) ? HIGH : LOW);
  digitalWrite(todData6, (data & 0x40) ? HIGH : LOW);
  digitalWrite(todData7, (data & 0x80) ? HIGH : LOW);
}

void outputTodParallel(const TodData& tod) {
  // === –í–´–í–û–î –í–†–ï–ú–ï–ù–ò ===
  digitalWrite(todSelect, LOW); // –í—ã–±–∏—Ä–∞–µ–º –≤—Ä–µ–º—è
  
  // –ü–∞–∫–µ—Ç 1: –°–µ–∫—É–Ω–¥—ã + –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã (–º–ª–∞–¥—à–∏–π –±–∞–π—Ç)
  uint16_t timeData1 = (tod.seconds << 8) | (tod.milliseconds & 0xFF);
  outputDataToBus(timeData1);
  digitalWrite(todStrobe, HIGH);
  delayMicroseconds(10);
  digitalWrite(todStrobe, LOW);
  delayMicroseconds(10);
  
  // –ü–∞–∫–µ—Ç 2: –ß–∞—Å—ã + –º–∏–Ω—É—Ç—ã
  uint16_t timeData2 = (tod.hours << 8) | tod.minutes;
  outputDataToBus(timeData2);
  digitalWrite(todStrobe, HIGH);
  delayMicroseconds(10);
  digitalWrite(todStrobe, LOW);
  delayMicroseconds(10);
  
  // === –í–´–í–û–î –î–ê–¢–´ ===
  digitalWrite(todSelect, HIGH); // –í—ã–±–∏—Ä–∞–µ–º –¥–∞—Ç—É
  
  // –ü–∞–∫–µ—Ç 3: –î–µ–Ω—å + –º–µ—Å—è—Ü
  uint16_t dateData1 = (tod.day << 8) | tod.month;
  outputDataToBus(dateData1);
  digitalWrite(todStrobe, HIGH);
  delayMicroseconds(10);
  digitalWrite(todStrobe, LOW);
  delayMicroseconds(10);
  
  // –ü–∞–∫–µ—Ç 4: –ì–æ–¥ (–º–ª–∞–¥—à–∏–µ 8 –±–∏—Ç) + –¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏
  uint16_t dateData2 = ((tod.year & 0xFF) << 8) | tod.dayOfWeek;
  outputDataToBus(dateData2);
  digitalWrite(todStrobe, HIGH);
  delayMicroseconds(10);
  digitalWrite(todStrobe, LOW);
  delayMicroseconds(10);
  
  // –ü–∞–∫–µ—Ç 5: –°—Ç–∞—Ä—à–∏–π –±–∞–π—Ç –≥–æ–¥–∞ + —Å—Ç–∞—Ç—É—Å
  uint16_t dateData3 = ((tod.year >> 8) << 8) | (tod.ppsLocked ? 0x01 : 0x00);
  outputDataToBus(dateData3);
  digitalWrite(todStrobe, HIGH);
  delayMicroseconds(10);
  digitalWrite(todStrobe, LOW);
}

void generateTodOutput(bool fromPps = false) {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏");
    return;
  }
  
  TodData tod;
  // –í—Ä–µ–º—è
  tod.hours = timeinfo.tm_hour;
  tod.minutes = timeinfo.tm_min;
  tod.seconds = timeinfo.tm_sec;
  tod.milliseconds = millis() % 1000;
  
  // –î–∞—Ç–∞
  tod.day = timeinfo.tm_mday;
  tod.month = timeinfo.tm_mon + 1;
  tod.year = timeinfo.tm_year + 1900;
  tod.dayOfWeek = timeinfo.tm_wday;
  
  // –°—Ç–∞—Ç—É—Å
  tod.ppsCounter = ppsCounter;
  
  unsigned long sinceLastStable = micros() - lastStablePps;
  tod.ppsLocked = (sinceLastStable < 2000000) && (stablePpsCount > 10);
  
  if (fromPps) {
    updateTimeFromPps();
    externalClockActive = true;
  }
  
  // –í—ã–≤–æ–¥ –≤ Serial
  outputTodSerial(tod);
  
  // –í—ã–≤–æ–¥ –≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ —á–µ—Ä–µ–∑ –æ–¥–∏–Ω RJ45
  outputTodParallel(tod);
}

void setupPins() {
  // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∏–Ω–æ–≤ –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ TOD –≤—ã–≤–æ–¥–∞
  pinMode(todData0, OUTPUT);
  pinMode(todData1, OUTPUT);
  pinMode(todData2, OUTPUT);
  pinMode(todData3, OUTPUT);
  pinMode(todData4, OUTPUT);
  pinMode(todData5, OUTPUT);
  pinMode(todData6, OUTPUT);
  pinMode(todData7, OUTPUT);
  pinMode(todStrobe, OUTPUT);
  pinMode(todSelect, OUTPUT);
  
  // –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  digitalWrite(todStrobe, LOW);
  digitalWrite(todSelect, LOW);
  
  // PPS –≤—Ö–æ–¥
  pinMode(ppsPin, INPUT_PULLUP);
}

void syncWithNtp() {
  Serial.println("üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å NTP...");
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  delay(2000);
  lastNtpSync = millis();
  
  struct tm timeinfo;
  if (getLocalTime(&timeinfo)) {
    Serial.printf("‚úÖ NTP: %04d-%02d-%02d %02d:%02d:%02d\n",
                 timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday,
                 timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec);
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("===== ESP32 Full TOD Multiplexed =====");
  Serial.println("RJ45: GPIO12-19 (DATA), GPIO21 (STROBE), GPIO22 (SELECT)");
  Serial.println("Protocol: 5 packets per second (Time + Date)");

  setupPins();
  attachInterrupt(digitalPinToInterrupt(ppsPin), ppsInterrupt, RISING);

  WiFi.config(INADDR_NONE, INADDR_NONE, INADDR_NONE, IPAddress(8, 8, 8, 8));
  WiFi.begin(ssid, password);
  
  Serial.print("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\n‚úÖ WiFi –ø–æ–¥–∫–ª—é—á–µ–Ω");

  syncWithNtp();
  
  Serial.println("üöÄ –°–∏—Å—Ç–µ–º–∞ –∑–∞–ø—É—â–µ–Ω–∞. –ú—É–ª—å—Ç–∏–ø–ª–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π TOD");
}

void loop() {
  unsigned long currentMillis = millis();
  
  if (ppsReceived) {
    ppsReceived = false;
    generateTodOutput(true);
  }
  
  static unsigned long lastModeCheck = 0;
  if (currentMillis - lastModeCheck >= 1000) {
    unsigned long sinceLastStable = micros() - lastStablePps;
    
    if (externalClockActive && sinceLastStable > 2500000) {
      externalClockActive = false;
      Serial.println("‚ö†Ô∏è  –ü–æ—Ç–µ—Ä—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–≥–æ PPS");
    } else if (!externalClockActive && sinceLastStable < 1500000 && stablePpsCount > 5) {
      externalClockActive = true;
      Serial.println("‚úÖ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω PPS —Ä–µ–∂–∏–º");
    }
    lastModeCheck = currentMillis;
  }
  
  static unsigned long lastFreeOutput = 0;
  if (!externalClockActive && currentMillis - lastFreeOutput >= 1000) {
    generateTodOutput(false);
    lastFreeOutput = currentMillis;
  }
  
  if (currentMillis - lastNtpSync > 1800000) {
    syncWithNtp();
  }
  
  delay(1);
}
